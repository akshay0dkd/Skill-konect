rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isProfileOwner(userId) {
      return request.auth.uid == userId;
    }

    // Restrict review updates to only the rating fields.
    function isReviewerUpdatingRating(userId) {
      let isNotOwner = request.auth.uid != userId;
      // Only rating and ratingCount can be changed.
      let onlyChangingRatingFields = request.resource.data.diff(resource.data).affectedKeys().hasOnly(['rating', 'ratingCount']);
      return isNotOwner && onlyChangingRatingFields;
    }

    match /users/{userId} {
      allow read: if request.auth != null;
      // Update is allowed by the profile owner OR a reviewer updating only the rating.
      allow update: if isProfileOwner(userId) || isReviewerUpdatingRating(userId);
      // A user can only create their own user document.
      allow create: if request.auth.uid == userId;


      match /reviews/{reviewId} {
        allow read: if request.auth != null;
        // The reviewerId must be the logged-in user, and they can't review themselves.
        allow create: if request.auth != null
                      && request.auth.uid != userId
                      && request.resource.data.reviewerId == request.auth.uid;
      }
    }

    match /mentorship_requests/{requestId} {
      allow read: if request.auth != null && (resource.data.fromUserId == request.auth.uid || resource.data.toUserId == request.auth.uid);
      allow create: if request.auth != null && request.resource.data.fromUserId == request.auth.uid;
      // Only the recipient can update, and they can only change the 'status' and 'updatedAt' fields.
      allow update: if request.auth != null
                    && resource.data.toUserId == request.auth.uid
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'updatedAt']);
    }

    match /conversations/{conversationId} {
      allow read: if request.auth != null && request.auth.uid in resource.data.participants;
      allow create: if request.auth != null && request.auth.uid in request.resource.data.participants;
      // Allow updates, but do not allow changing the participants list.
      allow update: if request.auth != null
                    && request.auth.uid in resource.data.participants
                    && request.resource.data.participants == resource.data.participants;

      match /messages/{messageId} {
        // A user must be a participant in the conversation to read or create messages.
        allow read, create: if request.auth != null && request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants;
      }
    }

    match /tasks/{taskId} {
      allow read: if request.auth != null && (resource.data.assignedTo == request.auth.uid || resource.data.assignedBy == request.auth.uid);
      allow create: if request.auth != null && request.resource.data.assignedBy == request.auth.uid;
      // The assignee can update the task, but only the 'status' and 'completed' fields.
      allow update: if request.auth != null
                    && resource.data.assignedTo == request.auth.uid
                    && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'completed']);
    }

    match /skills/{skillId} {
      // It's a public list of skills, so anyone can read it.
      allow read: if true;
    }

    match /authErrors/{errorId} {
      // Allow create for everyone to log auth errors. This is a trade-off.
      allow create: if true;
    }
  }
}
